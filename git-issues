#!/usr/bin/env python
# coding: utf-8

# git-issue, version 0.3
#
# by John Wiegley <johnw@newartisans.com>

# TODO: (until I can add these bugs to the repo itself!)
#
# 1. use utf-8 throughout
# 2. use -z flag for ls-tree
# 3. use UTC throughout

import sys
import os
import re
import string
import optparse

try:
    from cStringIO import StringIO
except:
    from StringIO import StringIO

import cPickle

from datetime   import datetime
from subprocess import Popen, PIPE
from os.path    import isdir, isfile, join

######################################################################

iso_fmt       = "%Y%m%dT%H%M%S"
options       = None
cache_version = 9

######################################################################

# You may wonder what dirtiness means below.  Here's the deal:
#
# An object is "self-dirty" if it itself has been changed, but possibly none
# of its children.  An object is "dirty" if its children have been changed,
# but possibly not itself.  Any dirtiness is cause for rewriting the object
# cache; only self-dirtiness of specific objects will cause the repository to
# be updated.

class Person:
    def __init__(self, name, email):
        self.name  = name
        self.email = email

    def __str__(self):
        return "%s <%s>" % (self.name, self.email)

class Comment:
    def __init__(self, issue, author, comment):
        self.issue       = issue
        self.author      = author
        self.comment     = comment
        self.created     = datetime.now()
        self.modified    = None
        self.self_dirty  = True
        self.attachments = []   # records filename and blob

    def mark_dirty(self):
        self.modified   = datetime.now()
        self.self_dirty = True
        self.issue.mark_dirty(False)

    def __getstate__(self):
        odict = self.__dict__.copy() # copy the dict since we change it
        del odict['self_dirty']      # remove self dirty flag
        return odict

    def __setstate__(self,dict):
        self.__dict__.update(dict)   # update attributes
        self.self_dirty = False

class Issue:
    def __init__(self, issueSet, author, title,
                 summary     = None,
                 description = None,
                 reporters   = [],
                 owners      = [],
                 assigned    = None,
                 carbons     = [],
                 status      = "new",
                 resolution  = None,
                 issue_type  = "defect",
                 components  = [],
                 version     = None,
                 milestone   = None,
                 severity    = "major",
                 priority    = "medium",
                 tags        = []):
        self.issueSet    = issueSet
        self.name        = None
        self.author      = author
        self.title       = title
        self.summary     = summary
        self.description = description
        self.reporters   = reporters
        self.owners      = owners
        self.assigned    = assigned
        self.carbons     = carbons
        self.status      = status
        self.resolution  = resolution
        self.issue_type  = issue_type
        self.components  = components
        self.version     = version
        self.milestone   = milestone
        self.severity    = severity
        self.priority    = priority
        self.tags        = tags
        self.created     = datetime.now()
        self.modified    = None
        self.changes     = {}
        self.dirty       = False
        self.self_dirty  = True
        self.comments    = {}

    def mark_dirty(self, self_dirty):
        self.dirty = True
        if self_dirty:
            self.self_dirty = True
            self.modified   = datetime.now()
        self.issueSet.mark_dirty(False)

    def note_change(self, field, before, after):
        if self.changes.has_key(field):
            data = self.changes[field]
            data[1] = after
        else:
            data = [before, after]
        self.changes[field] = data

    def set_author(self, author):
        self.note_change('author', self.author, author)
        self.author = author

    def set_title(self, title):
        self.note_change('title', self.title, title)
        self.title = title

    def set_summary(self, summary):
        self.note_change('summary', self.summary, summary)
        self.summary = summary

    def set_description(self, description):
        self.note_change('description', self.description, description)
        self.description = description

    def set_reporters(self, reporters):
        self.note_change('reporters', self.reporters, reporters)
        self.reporters = reporters

    def set_owners(self, owners):
        self.note_change('owners', self.owners, owners)
        self.owners = owners

    def set_assigned(self, assigned):
        self.note_change('assigned', self.assigned, assigned)
        self.assigned = assigned

    def set_carbons(self, carbons):
        self.note_change('carbons', self.carbons, carbons)
        self.carbons = carbons

    def set_status(self, status):
        self.note_change('status', self.status, status)
        self.status = status

    def set_resolution(self, resolution):
        self.note_change('resolution', self.resolution, resolution)
        self.resolution = resolution

    def set_issue_type(self, issue_type):
        self.note_change('type', self.issue_type, issue_type)
        self.issue_type = issue_type

    def set_components(self, components):
        self.note_change('components', self.components, components)
        self.components = components

    def set_version(self, version):
        self.note_change('version', self.version, version)
        self.version = version

    def set_milestone(self, milestone):
        self.note_change('milestone', self.milestone, milestone)
        self.milestone = milestone

    def set_severity(self, severity):
        self.note_change('severity', self.severity, severity)
        self.severity = severity

    def set_priority(self, priority):
        self.note_change('priority', self.priority, priority)
        self.priority = priority

    def set_tags(self, tags):
        self.note_change('tags', self.tags, tags)
        self.tags = tags

    def format_long_text(self, text, indent = 13):
        if not text:
            return "<none>"

        lines = string.split(text, '\n')
        
        buffer = StringIO()
        first = True
        for line in lines:
            if not first:
                buffer.write("\n%s" % (" " * indent))
            else:
                first = False
            buffer.write(line)

        return buffer.getvalue()

    def format_people_list(self, people, indent = 13):
        if not people:
            return "<no one yet>"

        buffer = StringIO()
        first = True
        for person in people:
            if not first:
                buffer.write(",\n%s" % (" " * indent))
            else:
                first = False
            buffer.write(person)

        return buffer.getvalue()

    def __getstate__(self):
        odict = self.__dict__.copy() # copy the dict since we change it
        del odict['changes']         # remove change log
        del odict['dirty']           # remove dirty flag
        del odict['self_dirty']      # remove self dirty flag
        return odict

    def __setstate__(self,dict):
        self.__dict__.update(dict)   # update attributes
        self.changes = {}
        self.dirty      = False
        self.self_dirty = False

class IssueSet:
    """An IssueSet refers to a group of issues.  There is always at least one
    IssueSet that refers to all of the issues which exist in a repository.
    Other IssueSet's can be generated from that one as "views" or queries into
    that data.

    In essence, it contains both a set of Issue's which can be looked up by
    their unique identifier, and also certain global definition, like the
    allowable components, etc."""
    def __init__(self):
        self.statuses      = []
        self.resolutions   = []
        self.issue_types   = []
        self.components    = []
        self.versions      = []
        self.milestones    = []
        self.severities    = []
        self.priorities    = []
        self.issues        = {}
        self.issues_HEAD   = None
        self.dirty         = False
        self.self_dirty    = True
        self.cache_version = cache_version
        self.created       = datetime.now()
        self.modified      = None

    def mark_dirty(self, self_dirty):
        self.dirty = True
        if self_dirty:
            self.modified   = datetime.now()
            self.self_dirty = True

    def head(self):
        if not self.issues_HEAD:
            self.issues_HEAD = self.current_head()
        return self.issues_HEAD

    def update_head(self, new_head):
        # Update the HEAD of the issues branch to point to the new_head
        git('update-ref', 'refs/heads/issues', new_head, self.current_head())
        self.issues_HEAD = new_head
        self.mark_dirty(False)

    def current_head(self):
        assert False

    def current_author(self):
        assert False

    def read_project(self):
        pass

    def read_issues(self):
        assert False

    def add_issue(self, issue):
        self.issues[issue.name] = issue

    def read_issue(self, name):
        assert False
    def write_issue(self, issue):
        assert False

    def issues_cache_file(self):
        assert False
    
    def load_state(cls, issueSet):
        """Given a newly created IssueSet object as a template, see if we can
        restore the cached version of the data from disk, and then check whether
        it's still valid.  This can _greatly_ speed up subsequent list and show
        operations.

        The reason why a newly created template exists is to abstract
        DVCS-specific behavior, such as the location of the cache file.

        Thus, a typical session looks like this:

          issueSet = GitIssueSet()   # or whichever DVCS backend you use

          if ... looking at issues list is required ...:
              issueSet = load_issues(issueSet)

              ... use the issue data ..."""
        cache_file = issueSet.issues_cache_file()
        if isfile(cache_file):
            fd = open(cache_file, 'rb')
            if options.verbose:
                print "Cache: Loading saved issues data"
            try:
                cachedIssueSet = cPickle.load(fd)
            finally:
                fd.close()

            if cachedIssueSet.cache_version == issueSet.cache_version and \
               cachedIssueSet.head() == issueSet.current_head():
                if options.verbose:
                    print "Cache: It is valid and usable"
                return cachedIssueSet

            if options.verbose:
                print "Cache: No longer valid, throwing it away"

        # We can't use or rely on the cache, so read all details from disk and
        # then mark the IssueSet dirty so that it gets saved back again when
        # we exit.
        issueSet.read_project()
        issueSet.read_issues()
        issueSet.mark_dirty(False)

        return issueSet

    load_state = classmethod(load_state)

    def save_state(self):
        """Write an IssueSet to disk in object form, for fast loading on the next
        iteration.  This is only done if there are actual changes to write."""
        if self.dirty:
            for name in self.issues.keys():
                issue = self.issues[name]
                if issue.self_dirty:
                    if issue.name:
                        self.update_issue(issue)
                    else:
                        self.write_issue(issue)

            cache_file     = self.issues_cache_file()
            cache_file_dir = os.path.dirname(cache_file)

            if not isdir(cache_file_dir):
                os.makedirs(cache_file_dir)

            fd = open(cache_file, 'wb')
            try:
                cPickle.dump(issueSet, fd)
            finally:
                fd.close()

            self.dirty = False

######################################################################

import xml.dom.minidom

def read_object(obj, file_descriptor):
    return XmlReader.read(file_descriptor)

def object_from_string(str):
    return XmlReader.readString(str)

class XmlReader:
    def read(cls, fd):
        doc = xml.dom.minidom.parse(fd)
        data = XmlRipper.rip(doc.firstChild)
        doc.unlink()
        return data

    read = classmethod(read)

    def readString(cls, data):
        doc = xml.dom.minidom.parseString(data)
        data = XmlRipper.rip(doc.firstChild)
        doc.unlink()
        return data

    readString = classmethod(readString)

class XmlStringRipper:
    def rip(cls, node):
        return node.data[1:-1]

    rip = classmethod(rip)

class XmlListRipper:
    def rip(cls, node):
        assert False

    rip = classmethod(rip)

class XmlDateTimeRipper:
    def rip(cls, node):
        return datetime.strptime(node.childNodes[0].data[1:-1], iso_fmt)

    rip = classmethod(rip)

class XmlPersonRipper:
    def rip(cls, node):
        person = Person(node.childNodes[1].childNodes[0].data[1:-1],
                        node.childNodes[3].childNodes[0].data[1:-1])
        return person

    rip = classmethod(rip)

class XmlIssueRipper:
    def rip(cls, node):
        created = XmlRipper.rip(node.childNodes[1].childNodes[1])
        author  = XmlRipper.rip(node.childNodes[3].childNodes[1])
        title   = XmlRipper.rip(node.childNodes[5].firstChild)

        issue = Issue(None, author, title)
        issue.created = created
        issue.dirty   = False

        return issue

    rip = classmethod(rip)

class XmlIssueSetRipper:
    pass

class XmlRipper:
    def rip(cls, node):
        if node.nodeType == xml.dom.minidom.Node.TEXT_NODE:
            return XmlStringRipper.rip(node)
        elif node.nodeName == 'datetime':
            return XmlDateTimeRipper.rip(node)
        elif node.nodeName == 'person':
            return XmlPersonRipper.rip(node)
        elif node.nodeName == 'list':
            return XmlListRipper.rip(node)
        elif node.nodeName == 'issue':
            return XmlIssueRipper.rip(node)
        elif node.nodeName == 'issue-set':
            return XmlIssueSetRipper.rip(node)
        else:
            print node.nodeType
            print node.nodeName
            assert False

    rip = classmethod(rip)

######################################################################

def write_object(obj, file_descriptor = sys.stdout):
    XmlWriter.write(XmlBuilder.build(obj), fd = file_descriptor)

def object_to_string(obj):
    buffer = StringIO()
    XmlWriter.write(XmlBuilder.build(obj), fd = buffer)
    return buffer.getvalue()

class XmlWriter:
    def write(cls, doc, no_header = False, fd = sys.stdout):
        if no_header:
            buffer = StringIO()
            buffer.write(doc.toprettyxml(indent = "", encoding = "utf-8"))
            fd.write(re.sub('^.+\n', '', buffer.getvalue()))
        else:
            fd.write(doc.toprettyxml(indent = "", encoding = "utf-8"))
        doc.unlink()

    write = classmethod(write)

class XmlStringBuilder:
    def build(cls, data, node, doc):
        node.appendChild(doc.createTextNode(data))

    build = classmethod(build)

class XmlListBuilder:
    def build(cls, data, node, doc):
        element = doc.createElement("list")
        for child in data:
            XmlBuilder.build(doc, element, child)
        node.appendChild(element)

    build = classmethod(build)

class XmlDateTimeBuilder:
    def build(cls, data, node, doc):
        element = doc.createElement("datetime")
        element.appendChild(doc.createTextNode(data.strftime(iso_fmt)))
        node.appendChild(element)

    build = classmethod(build)

class XmlPersonBuilder:
    def build(cls, data, node, doc):
        person = doc.createElement("person")

        name = doc.createElement("name")
        name.appendChild(doc.createTextNode(data.name))
        person.appendChild(name)

        email = doc.createElement("email")
        email.appendChild(doc.createTextNode(data.email))
        person.appendChild(email)

        node.appendChild(person)

    build = classmethod(build)

class XmlIssueBuilder:
    def build(cls, issue, node, doc):
        issueNode = doc.createElement("issue")

        created = doc.createElement("created")
        XmlBuilder.build(issue.created, created, doc)
        issueNode.appendChild(created)

        author = doc.createElement("author")
        XmlBuilder.build(issue.author, author, doc)
        issueNode.appendChild(author)

        title = doc.createElement("title")
        XmlBuilder.build(issue.title, title, doc)
        issueNode.appendChild(title)

        summary = doc.createElement("summary")
        XmlBuilder.build(issue.summary, summary, doc)
        issueNode.appendChild(summary)

        description = doc.createElement("description")
        XmlBuilder.build(issue.description, description, doc)
        issueNode.appendChild(description)

        reporters = doc.createElement("reporters")
        XmlBuilder.build(issue.reporters, reporters, doc)
        issueNode.appendChild(reporters)

        owners = doc.createElement("owners")
        XmlBuilder.build(issue.owners, owners, doc)
        issueNode.appendChild(owners)

        assigned = doc.createElement("assigned")
        XmlBuilder.build(issue.assigned, assigned, doc)
        issueNode.appendChild(assigned)

        carbons = doc.createElement("carbons")
        XmlBuilder.build(issue.carbons, carbons, doc)
        issueNode.appendChild(carbons)

        status = doc.createElement("status")
        XmlBuilder.build(issue.status, status, doc)
        issueNode.appendChild(status)

        resolution = doc.createElement("resolution")
        XmlBuilder.build(issue.resolution, resolution, doc)
        issueNode.appendChild(resolution)

        issue_type = doc.createElement("type")
        XmlBuilder.build(issue.issue_type, issue_type, doc)
        issueNode.appendChild(issue_type)

        components = doc.createElement("components")
        XmlBuilder.build(issue.components, components, doc)
        issueNode.appendChild(components)

        version = doc.createElement("version")
        XmlBuilder.build(issue.version, version, doc)
        issueNode.appendChild(version)

        milestone = doc.createElement("milestone")
        XmlBuilder.build(issue.milestone, milestone, doc)
        issueNode.appendChild(milestone)

        severity = doc.createElement("severity")
        XmlBuilder.build(issue.severity, severity, doc)
        issueNode.appendChild(severity)

        priority = doc.createElement("priority")
        XmlBuilder.build(issue.priority, priority, doc)
        issueNode.appendChild(priority)

        tags = doc.createElement("tags")
        XmlBuilder.build(issue.tags, tags, doc)
        issueNode.appendChild(tags)

        modified = doc.createElement("modified")
        XmlBuilder.build(issue.modified, modified, doc)
        issueNode.appendChild(modified)

        node.appendChild(issueNode)

    build = classmethod(build)

#class XmlIssueChangesBuilder:
#    def build(cls, data, node, doc):
#        changes = doc.createElement("changes")
#        doc.appendChild(changes)
#
#        for field_name in self.changes.keys():
#            field = doc.createElement("field")
#            field.setAttribute("name", field_name)
#
#            data = self.changes[field_name]
#
#            before = doc.createElement("before")
#            XmlBuilder.build(data[0], before, doc)
#            field.appendChild(before)
#
#            after = doc.createElement("after")
#            XmlBuilder.build(data[1], after, doc)
#            field.appendChild(after)
#
#            changes.appendChild(field)
#
#        node.appendChild(changes)
#
#    build = classmethod(build)

class XmlIssueSetBuilder:
    def build(cls, issueSet, node, doc):
        set = doc.createElement("issue-set")

        created = doc.createElement("created")
        XmlBuilder.build(issueSet.created, created, doc)
        set.appendChild(created)

        statuses = doc.createElement("statuses")
        XmlBuilder.build(issueSet.statuses, statuses, doc)
        set.appendChild(statuses)

        resolutions = doc.createElement("resolutions")
        XmlBuilder.build(issueSet.resolutions, resolutions, doc)
        set.appendChild(resolutions)

        issue_types = doc.createElement("types")
        XmlBuilder.build(issueSet.issue_types, issue_types, doc)
        set.appendChild(issue_types)

        components = doc.createElement("components")
        XmlBuilder.build(issueSet.components, components, doc)
        set.appendChild(components)

        versions = doc.createElement("versions")
        XmlBuilder.build(issueSet.versions, versions, doc)
        set.appendChild(versions)

        milestones = doc.createElement("milestones")
        XmlBuilder.build(issueSet.milestones, milestones, doc)
        set.appendChild(milestones)

        severities = doc.createElement("severities")
        XmlBuilder.build(issueSet.severities, severities, doc)
        set.appendChild(severities)

        priorities = doc.createElement("priorities")
        XmlBuilder.build(issueSet.priorities, priorities, doc)
        set.appendChild(priorities)

        modified = doc.createElement("modified")
        XmlBuilder.build(issueSet.modified, modified, doc)
        set.appendChild(modified)

        node.appendChild(set)

    build = classmethod(build)

class XmlBuilder:
    def build(cls, data, node = None, doc = None):
        if data is None:
            pass
        elif isinstance(data, datetime):
            assert doc
            XmlDateTimeBuilder.build(data, node, doc)
        elif isinstance(data, Person):
            assert doc
            XmlPersonBuilder.build(data, node, doc)
        elif isinstance(data, list):
            assert doc
            XmlListBuilder.build(data, node, doc)
        elif isinstance(data, str):
            assert doc
            XmlStringBuilder.build(data, node, doc)
        elif isinstance(data, Issue):
            assert not doc
            doc = xml.dom.minidom.Document()
            XmlIssueBuilder.build(data, doc, doc)
        elif isinstance(data, IssueSet):
            assert not doc
            doc = xml.dom.minidom.Document()
            XmlIssueSetBuilder.build(data, doc, doc)
        else:
            assert False

        return doc

    build = classmethod(build)

######################################################################

# Utility function for calling out to Git (this script does not try to
# be a Git library, just an interface to the underlying commands).  It
# supports a 'restart' keyword, which will cause a Python function to
# be called on failure.  If that function returns True, the same
# command will be attempted again.  This can avoid costly checks to
# make sure a branch exists, for example, by simply failing on the
# first attempt to use it and then allowing the restart function to
# create it.

def git(cmd, *args, **kwargs):
    restart = True
    while restart:
        stdin_mode = None
        if kwargs.has_key('input'):
            stdin_mode = PIPE

        if options.verbose:
            print "Command: git-%s %s" % (cmd, string.join(args, ' '))
            if kwargs.has_key('input'):
                print "Input: <<EOF"
                print kwargs['input'],
                print "EOF"

        proc = Popen(('git-' + cmd,) + args, stdin = stdin_mode,
                     stdout = PIPE, stderr = PIPE)

        if kwargs.has_key('input'):
            proc.stdin.write(kwargs['input'])
            proc.stdin.close()

        returncode = proc.wait()
        restart = False
        if returncode != 0:
            if kwargs.has_key('restart'):
                if kwargs['restart'](cmd, args, kwargs):
                    restart = True
            else:
                if not kwargs.has_key('no_stderr') and proc.stderr:
                    sys.stderr.write(proc.stderr.read())
                raise Exception("Could not complete call: git-%s %s" %
                                (cmd, args))

    if not kwargs.has_key('ignore_output'):
        return proc.stdout.read()[:-1]

class gitbook:
    """Abstracts a reference to a data file within a Git repository.  It also
    maintains knowledge of whether the object has been modified or not."""
    def __init__(self, shelf, path, hash = None):
        self.shelf = shelf
        self.path  = path
        self.hash  = hash
        self.data  = None
        self.dirty = False

    def data(self):
        if self.data is None:
            assert self.hash is not None
            self.data = git('cat-file', 'blob', self.hash)
        return self.data
        
    def set_data(self, data):
        self.hash = None
        self.data = data
        self.mark_dirty()
        
    def mark_dirty(self):
        self.dirty = True

    def __getstate__(self):
        odict = self.__dict__.copy() # copy the dict since we change it
        del odict['dirty']           # remove dirty flag
        return odict

    def __setstate__(self,dict):
        self.__dict__.update(dict)   # update attributes
        self.dirty = False


class gitshelve(dict):
    """This class implements a Python "shelf" using a branch within a Git
    repository.  There is no "writeback" argument, meaning changes are only
    written upon calling close or sync.

    This implementation uses a dictionary of gitbook objects, since we don't
    really want to use Pickling within a Git repository (it's not friendly to
    other Git users, nor does it support merging)."""
    ls_tree_pat = re.compile('(040000 tree|100644 blob) ([0-9a-f]{40})\t(start|(.+))$')

    def __init__(self, branch):
        self.dirty      = False
        self.branch     = branch
        self.trees      = {}
        self.paths      = {}

    def create_branch(self, cmd, args, kwargs):
        """If an issues branch already exists at the remote, we simply refer
        to it from now on.  Otherwise, we create a dummy commit in order get
        things started."""
        try:
            hash = git('rev-parse', 'origin/%s' % self.branch,
                       no_stderr = True)
        except:
            msg  = "Created %s branch\n" % self.branch
            hash = git('hash-object', '-w', '--stdin', input = msg)
            hash = git('mktree', input = "100644 blob %s\tstart\n" % hash)
            hash = git('commit-tree', hash, input = msg)

        git('branch', self.branch, hash)
        return True

    def current_head(self):
        return git('rev-parse', self.branch, restart = self.create_branch)

    def open(cls, branch):
        shelf = gitshelve(branch)
        
        ls_tree = string.split(git('ls-tree', '-r', '-t', '-z',
                                   self.current_head()), '\0')
        for line in ls_tree:
            match = cls.ls_tree_pat.match(line)
            assert match

            hash = match.group(2)
            path = match.group(3)

            if match.group(1) == "040000 tree":
                parts = os.path.split(path)

                dict = shelf.trees

                for part in parts:
                    if not dict.has_key(part):
                        dict[part] = {}
                    dict = dict[part]

                dict['__root__'] = hash

            elif path == 'start':
                break

            else:
                assert not shelf.paths.has_key(path)
                shelf.paths[path] = gitbook(shelf, path, hash)

        return shelf

    open = classmethod(open)

    def sync(self):
        if self.dirty:
            for book in self.paths:
                if book.dirty:
                    self.sync_book(book)
        self.dirty = False

    def sync_book(self, book):
        # Create a unique blob to represent the new issue.  This is the
        # issue's official object name from now on, and will never change.
        blob = git('hash-object', '-w', '--stdin', input = repr(book))
        book.hash  = blob
        book.dirty = False

        tree = git('mktree', input = "100644 blob %s\tinfo\n" % blob)

        # Merge this blob with existing issue blobs that share the same
        # first two hash digits
        if self.trees.has_key(blob[:2]):
            parent = self.trees[blob[:2]]
        else:
            parent = [None]
            self.trees[blob[:2]] = parent
        parent.append((tree, blob[2:]))

        buffer = StringIO()
        for child in parent[1:]:
            buffer.write("040000 tree %s\t%s\n" % (child[0], child[1]))

        tree = git('mktree', input = buffer.getvalue())

        self.trees[blob[:2]][0] = tree

        # Merge it into the tree of issues overall
        keys = self.trees.keys()
        keys.sort()

        buffer = StringIO()
        for key in keys:
            buffer.write("040000 tree %s\t%s\n" % (self.trees[key][0], key))

        tree = git('mktree', input = buffer.getvalue())

        # Commit the merged tree (though at this moment it's a dangling commit)
        commit = git('commit-tree', tree, '-p', self.current_head(),
                     input = book.title)

        # Update the head of the issues branch to point to the new commit
        self.update_head(commit)

    def close(self):
        if self.dirty:
            self.sync()
        del self.objects        # free it up right away

    def __getitem__(self, path):
        return self.paths[path].data()

    def __setitem__(self, path, data):
        if not self.paths.has_key(path):
            self.paths[path] = gitbook(self, path)
        self.paths[path].set_data(data)
        self.dirty = True

    def __detitem__(self, path):
        del self.paths[path]

    def __contains__(self, path):
        return self.paths.has_key()

    def __iter__(self):
        pass

    def iteritems(self):
        pass

class GitIssueSet(IssueSet):
    """This object implements all the command necessary to interact with Git
    for the purpose of storing and distributing issues."""
    ls_tree_pat = re.compile('(040000 tree|100644 blob) ([0-9a-f]{40})\t(project|([0-9a-f]{2})(/([0-9a-f]{38})(/(.+))?)?)$')

    def __init__(self):
        self.GIT_DIR    = None
        self.GIT_AUTHOR = None
        self.trees      = {}
        IssueSet.__init__(self)

    def git_directory(self):
        if self.GIT_DIR is None:
            self.GIT_DIR = git('rev-parse', '--git-dir')
        return self.GIT_DIR

    def issues_cache_file(self):
        return join(self.git_directory(), "issues")

    def create_issue_branch(self, cmd, args, kwargs):
        """If an issues branch already exists at the remote, we simply refer
        to it from now on.  Otherwise, we create a dummy commit in order get
        things started."""
        try:
            hash = git('rev-parse', 'origin/issues', no_stderr = True)
        except:
            hash = git('hash-object', '-w', '--stdin',
                       input = "Created issues branch\n")
            hash = git('mktree', input = "100644 blob %s\tproject\n" % hash)
            hash = git('commit-tree', hash, input = object_to_string(self))

        git('branch', 'issues', hash)
        return True

    def current_head(self):
        return git('rev-parse', 'issues', restart = self.create_issue_branch)

    def current_author(self):
        if self.GIT_AUTHOR is None:
            self.GIT_AUTHOR = Person(git('config', 'user.name'),
                                     git('config', 'user.email'))
        return self.GIT_AUTHOR

    def read_issue(self, name):
        hash = git('rev-parse', 'issues:%s/%s/info' % (name[:2], name[2:]))
        data = git('cat-file', 'blob', hash)
        issue = object_from_string(data)
        issue.name     = name
        issue.issueSet = self
        return issue

    def update_issue(self, issue):
        print "Updated issue %s" % issue.name

    def write_issue(self, issue):
        """Create a new issue in the tracking database by building a commit
        object that holds a reference to a unique blob describing the issue.
        Its uniqueness is determined by hashing the time of creation, the
        creator's name and e-mail address, and the title of the issues.  The
        issue is then kept under a sub-directory of the same name within the
        issues branch, in a fashion similar to `.git/objects`."""
        assert issue.name is None

        # Create a unique blob to represent the new issue.  This is the
        # issue's official object name from now on, and will never change.
        blob = git('hash-object', '-w', '--stdin',
                   input = object_to_string(issue))
        issue.name = blob

        tree = git('mktree', input = "100644 blob %s\tinfo\n" % blob)

        # Merge this blob with existing issue blobs that share the same
        # first two hash digits
        if self.trees.has_key(blob[:2]):
            parent = self.trees[blob[:2]]
        else:
            parent = [None]
            self.trees[blob[:2]] = parent
        parent.append((tree, blob[2:]))

        buffer = StringIO()
        for child in parent[1:]:
            buffer.write("040000 tree %s\t%s\n" % (child[0], child[1]))

        tree = git('mktree', input = buffer.getvalue())

        self.trees[blob[:2]][0] = tree

        # Merge it into the tree of issues overall
        keys = self.trees.keys()
        keys.sort()

        buffer = StringIO()
        for key in keys:
            buffer.write("040000 tree %s\t%s\n" % (self.trees[key][0], key))

        tree = git('mktree', input = buffer.getvalue())

        # Commit the merged tree (though at this moment it's a dangling commit)
        commit = git('commit-tree', tree, '-p', self.current_head(),
                     input = issue.title)

        # Update the head of the issues branch to point to the new commit
        self.update_head(commit)

        print "Created issue %s" % issue.name

    def read_issues(self):
        print "Reading issues list from repository..."

        ls_tree = string.split(git('ls-tree', '-r', '-t', '-z',
                                   self.head()), '\0')

        self.issues = {}        # clear any existing data
        self.trees  = {}

        for line in ls_tree:
            match = self.ls_tree_pat.match(line)
            assert match

            hash = match.group(2)
            path = match.group(3)

            if match.group(1) == "040000 tree":
                if len(path) == 2:
                    self.trees[path] = [hash]
                else:
                    self.trees[match.group(4)].append((hash, match.group(6)))

            elif path == 'project':
                break

            else:
                assert hash == match.group(4) + match.group(6)

                self.add_issue(self.read_issue(hash))

        return self.issues

######################################################################

parser = optparse.OptionParser()
parser.add_option("-v", "--verbose",
                  action  = "store_true",
                  dest    = "verbose",
                  default = False,
                  help    = "report activity options.verbosely")

(options, args) = parser.parse_args()

def get_issue(issueSet, id):
    issue = None
    try:
        idx = int(id) - 1
        issue = issueSet.issues[issueSet.issues.keys()[idx]]
    except:
        for name in issueSet.issues.keys():
            if re.match(id, name):
                issue = issueSet.issues[name]
                break

    if not issue:
        raise Exception("There is no issue matching the identifier '%s'.\n" % id)

    return issue

######################################################################

if __name__ == '__main__':

    if len(args) == 0:
        print "Show help here."
        sys.exit(1)

    command = args[0]
    args    = args[1:]

######################################################################

    # jww (2008-05-12): Pick the appropriate IssueSet to used based on what we
    # find in our environment.

    issueSet = IssueSet.load_state(GitIssueSet())

######################################################################

    if command == "list":
        print
        print "   #    Id     Title                   State  Date  Assign  Tags"
        print "-------------------------------------------------------------------------------"

        index = 1
        for name in issueSet.issues.keys():
            issue = issueSet.issues[name]

            print "%4d  %s  %-23s %-6s %5s %6s %s" % \
                (index, issue.name[:7], issue.title, issue.status,
                 issue.created and issue.created.strftime('%m/%d'),
                 str(issue.author)[:6], '')

            index += 1

        print

######################################################################

    elif command == "show" or command == "dump":
        if len(args) == 0:
            print "Shows needs an index or Id."

        issue = get_issue(issueSet, args[0])
        if command == "show":
            sys.stdout.write("""
          Title: %s
        Summary: %s

    Description: %s

         Author: %s
       Reporter: %s
          Owner: %s
       Assigned: %s
             Cc: %s

           Type: %s
         Status: %s
     Resolution: %s
     Components: %s
        Version: %s
      Milestone: %s
       Severity: %s
       Priority: %s
           Tags: %s

        Created: %s
       Modified: %s

    """ % (issue.title,
           issue.format_long_text(issue.summary),

           issue.format_long_text(issue.description),

           issue.author,
           issue.format_people_list(issue.reporters),
           issue.format_people_list(issue.owners),
           issue.format_people_list(issue.assigned),
           issue.format_people_list(issue.carbons),

           issue.issue_type,
           issue.status,
           issue.resolution or "",
           issue.components or "",
           issue.version or "",
           issue.milestone or "",
           issue.severity,
           issue.priority,
           issue.tags or "",

           issue.created,
           issue.modified))
        else:
            write_object(issue)

######################################################################

    elif command == "change":
        if len(args) == 0:
            print "Change needs an issue."

        issue = get_issue(issueSet, args[0])

        # jww (2008-05-13): Need to parse datetime, lists, and people
        eval ("issue.set_%s(\"%s\")" % (args[1], args[2]))

######################################################################

    elif command == "new":
        if len(args) == 0:
            print "New needs a title."

        issue = Issue(issueSet, issueSet.current_author(), args[0])
        issueSet.add_issue(issue)
        issue.mark_dirty(True)

######################################################################

    # If any of the commands made the issueSet dirty, (possibly) update the
    # repository and write out a new cache

    issueSet.save_state()

######################################################################

    sys.exit(0)

# git-issue ends here
