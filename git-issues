#!/usr/bin/env python
# coding: utf-8

# git-issue, version 0.2
#
# by John Wiegley <johnw@newartisans.com>

# TODO: (until I can add these bugs to the repo itself!)
#
# 1. use utf-8 throughout
# 2. use -z flag for ls-tree
# 3. use UTC throughout

import sys
import os
import re
import string
import optparse

try:
    from cStringIO import StringIO
except:
    from StringIO import StringIO

import cPickle

from datetime   import datetime
from subprocess import Popen, PIPE
from os.path    import isdir, isfile, join

######################################################################

iso_fmt       = "%Y%m%dT%H%M%S"
options       = None
cache_version = 6

######################################################################

class Person:
    def __init__(self, name, email):
        self.name  = name
        self.email = email

    def __str__(self):
        return "%s <%s>" % (self.name, self.email)

    def appendPerson(self, doc, parent, fd = sys.stdout):
        person = doc.createElement("person")
        parent.appendChild(person)

        name = doc.createElement("name")
        name.appendChild(doc.createTextNode(self.name))
        person.appendChild(name)

        email = doc.createElement("email")
        email.appendChild(doc.createTextNode(self.email))
        person.appendChild(email)

class Issue:
    def __init__(self, issueSet, author, title,
                 summary     = None,
                 description = None,
                 reporters   = [],
                 owners      = [],
                 assigned    = None,
                 carbons     = [],
                 status      = "new",
                 resolution  = None,
                 type        = "defect",
                 components  = [],
                 version     = None,
                 milestone   = None,
                 severity    = "major",
                 priority    = "medium",
                 tags        = []):
        self.issueSet    = issueSet
        self.name        = None
        self.author      = author
        self.title       = title
        self.summary     = summary
        self.description = description
        self.reporters   = reporters
        self.owners      = owners
        self.assigned    = assigned
        self.carbons     = carbons
        self.status      = status
        self.resolution  = resolution
        self.type        = type
        self.components  = components
        self.version     = version
        self.milestone   = milestone
        self.severity    = severity
        self.priority    = priority
        self.tags        = tags
        self.created     = datetime.now()
        self.modified    = None

    def format_long_text(self, text, indent = 13):
        if not text:
            return "<none>"

        lines = string.split(text, '\n')
        
        buffer = StringIO()
        first = True
        for line in lines:
            if not first:
                buffer.write("\n%s" % (" " * indent))
            else:
                first = False
            buffer.write(line)

        return buffer.getvalue()

    def format_people_list(self, people, indent = 13):
        if not people:
            return "<no one yet>"

        buffer = StringIO()
        first = True
        for person in people:
            if not first:
                buffer.write(",\n%s" % (" " * indent))
            else:
                first = False
            buffer.write(person)

        return buffer.getvalue()

    def show(self, fd = sys.stdout):
        fd.write("""
      Title: %s
    Summary: %s

Description: %s

     Author: %s
   Reporter: %s
      Owner: %s
   Assigned: %s
         Cc: %s

       Type: %s
     Status: %s
 Resolution: %s
 Components: %s
    Version: %s
  Milestone: %s
   Severity: %s
   Priority: %s
       Tags: %s
   
    Created: %s
   Modified: %s

""" % (self.title,
       self.format_long_text(self.summary),

       self.format_long_text(self.description),

       self.author,
       self.format_people_list(self.reporters),
       self.format_people_list(self.owners),
       self.format_people_list(self.assigned),
       self.format_people_list(self.carbons),

       self.type,
       self.status,
       self.resolution or "",
       self.components or "",
       self.version or "",
       self.milestone or "",
       self.severity,
       self.priority,
       self.tags or "",

       self.created,
       self.modified))

    def dump_xml(self, fd = sys.stdout):
        import xml.dom.minidom

        doc = xml.dom.minidom.Document()
        issue = doc.createElement("issue")
        doc.appendChild(issue)

        name = doc.createElement("name")
        name.appendChild(doc.createTextNode(self.name))
        issue.appendChild(name)

        title = doc.createElement("title")
        title.appendChild(doc.createTextNode(self.title))
        issue.appendChild(title)

        if self.summary:
            summary = doc.createElement("summary")
            summary.appendChild(doc.createTextNode(self.summary))
            issue.appendChild(summary)

        if self.description:
            description = doc.createElement("description")
            description.appendChild(doc.createTextNode(self.description))
            issue.appendChild(description)

        author = doc.createElement("author")
        self.author.appendPerson(doc, author, fd)
        issue.appendChild(author)

        if self.reporters:
            reporters = doc.createElement("reporters")
            for reporter in self.reporters:
                reporter.appendPerson(doc, reporters, fd)
                reporters.appendChild(reporter)

        if self.owners:
            owners = doc.createElement("owners")
            for owner in self.owners:
                owner.appendPerson(doc, owners, fd)
                owners.appendChild(owner)

        if self.assigned:
            assigned = doc.createElement("assigned")
            for assignee in self.assigned:
                assignee.appendPerson(doc, assigned, fd)
                assigned.appendChild(assignee)

        if self.carbons:
            carbons = doc.createElement("carbons")
            for carbon in self.carbons:
                carbon.appendPerson(doc, carbons, fd)
                carbons.appendChild(carbon)

        if self.status:
            status = doc.createElement("status")
            status.appendChild(doc.createTextNode(self.status))
            issue.appendChild(status)

        if self.resolution:
            resolution = doc.createElement("resolution")
            resolution.appendChild(doc.createTextNode(self.resolution))
            issue.appendChild(resolution)

        if self.type:
            type = doc.createElement("type")
            type.appendChild(doc.createTextNode(self.type))
            issue.appendChild(type)

        if self.components:
            components = doc.createElement("components")
            for component in self.components:
                element = doc.createElement("component")
                element.appendChild(doc.createTextNode(component))
                components.appendChild(element)

        if self.version:
            version = doc.createElement("version")
            version.appendChild(doc.createTextNode(self.version))
            issue.appendChild(version)

        if self.milestone:
            milestone = doc.createElement("milestone")
            milestone.appendChild(doc.createTextNode(self.milestone))
            issue.appendChild(milestone)

        if self.severity:
            severity = doc.createElement("severity")
            severity.appendChild(doc.createTextNode(self.severity))
            issue.appendChild(severity)

        if self.priority:
            priority = doc.createElement("priority")
            priority.appendChild(doc.createTextNode(self.priority))
            issue.appendChild(priority)

        if self.tags:
            tags = doc.createElement("tags")
            for tag in self.tags:
                element = doc.createElement("tag")
                element.appendChild(doc.createTextNode(tag))
                tags.appendChild(element)

        created = doc.createElement("created")
        created.appendChild(doc.createTextNode(self.created.strftime(iso_fmt)))
        issue.appendChild(created)

        if self.modified:
            modified = doc.createElement("modified")
            modified.appendChild(doc.createTextNode(self.modified.strftime(iso_fmt)))
            issue.appendChild(modified)

        fd.write(doc.toprettyxml(indent = "", encoding = "utf-8"))

class IssueSet:
    """An IssueSet refers to a group of issues.  There is always at least one
    IssueSet that refers to all of the issues which exist in a repository.
    Other IssueSet's can be generated from that one as "views" or queries into
    that data.

    In essence, it contains both a set of Issue's which can be looked up by
    their unique identifier, and also certain global definition, like the
    allowable components, etc."""
    def __init__(self):
        self.statuses    = []
        self.resolutions = []
        self.types       = []
        self.components  = []
        self.versions    = []
        self.milestones  = []
        self.severities  = []
        self.priorities  = []
        self.issues      = {}
        self.issues_HEAD = None
        self.dirty       = False

        self.cache_version = cache_version

    def head(self):
        if not self.issues_HEAD:
            self.issues_HEAD = self.current_head()
        return self.issues_HEAD

    def update_head(self, new_head):
        self.issues_HEAD = new_head

    def current_head(self):
        assert False

    def current_author(self):
        assert False

    def read_issues(self):
        self.dirty = True

    def write_issues(self):
        pass

    def read_issue(self, name):
        pass
    def write_issue(self, issue):
        pass

    def issues_cache_file(self):
        pass

def load_issues(issueSet):
    """Given a newly created IssueSet object as a template, see if we can
    restore the cached version of the data from disk, and then check whether
    it's still valid.  This can _greatly_ speed up subsequent list and show
    operations.

    The reason why a newly created template exists is to abstract
    DVCS-specific behavior, such as the location of the cache file.

    Thus, a typical session looks like this:

      issueSet = GitIssueSet()   # or whichever DVCS backend you use

      if ... looking at issues list is required ...:
          issueSet = load_issues(issueSet)

          ... use the issue data ..."""
    cache_file = issueSet.issues_cache_file()
    if isfile(cache_file):
        fd = open(cache_file, 'rb')
        if options.verbose:
            print "Cache: Loading saved issues data"
        try:
            cachedIssueSet = cPickle.load(fd)
        finally:
            fd.close()

        if cachedIssueSet.cache_version == issueSet.cache_version and \
           cachedIssueSet.head() == issueSet.current_head():
            if options.verbose:
                print "Cache: It's valid and we're using it"
            return cachedIssueSet

        if options.verbose:
            print "Cache: It's no longer valid, throwing it away"

    issueSet.read_issues()      # can't use cache, read from disk

    return issueSet

def save_issues(issueSet):
    """Write an IssueSet to disk in object form, for fast loading on the next
    iteration.  This is only done if there are actual changes to write."""
    if not issueSet.dirty:
        return

    cache_file = issueSet.issues_cache_file()
    cache_file_dir = os.path.dirname(cache_file)

    if not isdir(cache_file_dir):
        os.makedirs(cache_file_dir)

    fd = open(cache_file, 'wb')
    try:
        cPickle.dump(issueSet, fd)
    finally:
        fd.close()

######################################################################

# Utility function for calling out to Git (this script does not try to
# be a Git library, just an interface to the underlying commands).  It
# supports a 'restart' keyword, which will cause a Python function to
# be called on failure.  If that function returns True, the same
# command will be attempted again.  This can avoid costly checks to
# make sure a branch exists, for example, by simply failing on the
# first attempt to use it and then allowing the restart function to
# create it.

def git(cmd, *args, **kwargs):
    restart = True
    while restart:
        stdin_mode = None
        if kwargs.has_key('input'):
            stdin_mode = PIPE

        if options.verbose:
            print "Command: git-%s %s" % (cmd, string.join(args, ' '))
            if kwargs.has_key('input'):
                print "Input: <<EOF"
                print kwargs['input'],
                print "EOF"

        proc = Popen(('git-' + cmd,) + args, stdin = stdin_mode,
                     stdout = PIPE, stderr = PIPE)

        if kwargs.has_key('input'):
            proc.stdin.write(kwargs['input'])
            proc.stdin.close()

        returncode = proc.wait()
        restart = False
        if returncode != 0:
            if kwargs.has_key('restart'):
                if kwargs['restart'](cmd, args, kwargs):
                    restart = True
            else:
                if not kwargs.has_key('no_stderr') and proc.stderr:
                    sys.stderr.write(proc.stderr.read())
                raise Exception("Could not complete call: git-%s %s" %
                                (cmd, args))

    if not kwargs.has_key('ignore_output'):
        return proc.stdout.read()[:-1]

class GitIssueSet(IssueSet):
    """This object implements all the command necessary to interact with Git
    for the purpose of storing and distributing issues."""
    def __init__(self):
        self.GIT_DIR    = None
        self.GIT_AUTHOR = None
        IssueSet.__init__(self)

    def git_directory(self):
        if self.GIT_DIR is None:
            self.GIT_DIR = git('rev-parse', '--git-dir')
        return self.GIT_DIR

    def issues_cache_file(self):
        return join(self.git_directory(), "issues")

    def create_issue_branch(self, cmd, args, kwargs):
        """If an issues branch already exists at the remote, we simply refer
        to it from now on.  Otherwise, we create a dummy commit in order get
        things started."""
        try:
            hash = git('rev-parse', 'origin/issues', no_stderr = True)
        except:
            hash = git('hash-object', '-w', '--stdin',
                       input = "Created issues branch\n")
            hash = git('mktree', input = "100644 blob %s\tproject" % hash)
            hash = git('commit-tree', hash,
                       input = "Created: %s" % datetime.now().strftime(iso_fmt))

        git('branch', 'issues', hash)
        return True

    def current_head(self):
        return git('rev-parse', 'issues', restart = self.create_issue_branch)

    def current_author(self):
        if self.GIT_AUTHOR is None:
            self.GIT_AUTHOR = Person(git('config', 'user.name'),
                                     git('config', 'user.email'))
        return self.GIT_AUTHOR

    def read_issue(self, name):
        info = string.split(git('cat-file', 'blob', name), '\n')
        match = re.match('(.+) +<(.+)>$', info[1])
        assert match            # jww (2008-05-12): Be more resilient here
        issue = Issue(self, Person(match.group(1), match.group(2)), info[2])
        issue.name    = name
        issue.created = datetime.strptime(info[0], iso_fmt)
        return issue

    def update_issue(self, issue):
        pass

    def write_issue(self, issue):
        """Create a new issue in the tracking database by building a commit
        object that holds a reference to a unique blob describing the issue.
        Its uniqueness is determined by hashing the time of creation, the
        creator's name and e-mail address, and the title of the issues.  The
        issue is then kept under a sub-directory of the same name within the
        issues branch, in a fashion similar to `.git/objects`."""
        if issue.name is not None:
            self.update_issue(issue)
            return

        # Create a unique blob to represent the new issue.  This is the
        # issue's official object name from now on, and will never change.
        blob = git('hash-object', '-w', '--stdin',
                   input = "%s\n%s\n%s\n" % (datetime.now().strftime(iso_fmt),
                                             issue.author, issue.title))
        tree = git('mktree', input = "100644 blob %s\tinfo\n" % blob)

        issue.name = blob

        # Merge this blob with existing issue blobs that share the same
        # first two hash digits
        ls_tree = git('ls-tree', '-r', self.head(), '--', blob[:2])
        ls_tree = re.sub('\t%s/' % blob[:2], '\t', ls_tree)
        if ls_tree: ls_tree += '\n'

        tree = git('mktree', input =
                   (ls_tree + "040000 tree %s\t%s\n" % (tree, blob[2:])))

        # Merge it into the tree of issues overall
        ls_tree = git('ls-tree', self.head())
        ls_tree = re.sub('040000 tree [0-9a-f]{40}\t%s\n' % blob[:2],
                         '', ls_tree)
        if ls_tree: ls_tree += '\n'

        tree = git('mktree', input =
                   (ls_tree + "040000 tree %s\t%s\n" % (tree, blob[:2])))

        # Commit the merged tree (though at this moment it's a dangling commit)
        commit = git('commit-tree', tree, '-p', self.head(),
                     input = issue.title)

        # Update the HEAD of the issues branch to point to the commit we
        # just made.
        git('update-ref', 'refs/heads/issues', commit, self.head())

        # Reset the `issues_HEAD` global variable, then return the object
        # name of the new issue.
        self.update_head(commit)
        self.issues[issue.name] = issue
        issue.modified = datetime.now()
        self.dirty = True

    def read_issues(self):
        ls_tree = string.split(git('ls-tree', '-r', self.head()), '\n')

        self.issues = {}        # clear any existing data

        for line in ls_tree:
            match = re.match('100644 blob ([0-9a-f]{40})\t(project|([0-9a-f]{2})/([0-9a-f]{38})/info)',
                             line)
            assert match

            if match.group(2) == 'project':
                break

            hash = match.group(1)
            assert hash == match.group(3) + match.group(4)

            self.issues[hash] = self.read_issue(hash)

        IssueSet.read_issues(self) # set the dirty bit

        return self.issues

######################################################################

parser = optparse.OptionParser()
parser.add_option("-v", "--verbose",
                  action  = "store_true",
                  dest    = "verbose",
                  default = False,
                  help    = "report activity options.verbosely")

(options, args) = parser.parse_args()

######################################################################

if len(args) == 0:
    print "Show help here."
    sys.exit(1)

command = args[0]
args    = args[1:]

# jww (2008-05-12): Pick the appropriate IssueSet to used based on what we
# find in our environment.

issueSet = GitIssueSet()

if command == "list":
    issueSet = load_issues(issueSet)

    print "   #    Id     Title                   State  Date  Assign  Tags"
    print "-------------------------------------------------------------------------------"
    index = 1
    for name in issueSet.issues.keys():
        issue = issueSet.issues[name]
        print "%4d  %s  %-23s %-6s %5s %6s %s" % \
            (index, issue.name[:7], issue.title, issue.status,
             issue.created and issue.created.strftime('%m/%d'),
             str(issue.author)[:6], '')
        index += 1

elif command == "show" or command == "dump":
    if len(args) == 0:
        print "Shows needs an index or Id."

    issueSet = load_issues(issueSet)

    issue = None
    try:
        idx = int(args[0]) - 1
        issue = issueSet.issues[issueSet.issues.keys()[idx]]
    except:
        for name in issueSet.issues.keys():
            if re.match(args[0], name):
                issue = issueSet.issues[name]
                break

    if issue:
        if command == "show":
            issue.show()
        else:
            issue.dump_xml()
    else:
        sys.stderr.write("There is no issue matching the identifier '%s'.\n" %
                         args[0])

elif command == "new":
    if len(args) == 0:
        print "New needs a title."

    issue = Issue(issueSet, issueSet.current_author(), args[0])
    issueSet.write_issue(issue)
    print "New issue %s created." % issue.name

# If any of the commands made the issueSet dirty, write out a new cache
save_issues(issueSet)

sys.exit(0)

# git-issue ends here
